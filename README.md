# IA Projects

## [Project 1](P1)
### Heuristic Search Methods for One Player Solitaire Games

A solitaire game is characterized by the type of board and pieces, the rules of movement of the pieces
(possible operators/plays), and the conditions for ending the game with defeat (impossibility to solve,
maximum number of moves reached, time limit reached) or victory (solitaire solved), together with the
respective score. Typically, in the event of a win, a score is awarded depending on the number of moves,
resources spent, bonuses collected and/or time spent.

In addition to implementing a solitaire game for a human player, the program must be able to solve different
versions/levels of this game, using appropriate search methods, focusing on the comparison between
uninformed search methods (breadth-first search, depth-first search, iterative deepening, uniform cost) and
heuristic search methods (greedy search, A* Algorithm), with different heuristic functions. The algorithms
employed should be compared with several criteria, with emphasis on the quality of the solution obtained,
number of operations performed, maximum memory used, and time spent to obtain the solution.

The application should have a text or graphical use interface to show the evolution of the board and interact
with the user/player. You should allow a game mode in which the PC solves the solitaire alone using the
algorithm and respective configuration as selected by the user. Optionally, you can allow a Human game
mode in which the user can solve the game, while asking the PC for “hints”.

Selected Game : [Unequal Length Mazes](https://erich-friedman.github.io/puzzle/unequal/)


## [Project 2](P2)

### Natural Language Processing

For NLP problems, the aim is to process textual data, employing diverse techniques to transform them into
appropriate datasets that can then be addressed using supervised learning algorithms. An initial exploratory
data analysis should be carried out (class distribution, word distribution per class based on TF-IDF, and so on).
Different pre-processing and feature engineering techniques should be tried out. The employed machine
learning algorithms should be tested and compared (performance on the test set, confusion matrix, precision,
recall, accuracy, F1 measure, time spent to train/test the models).
At least 3 machine learning algorithms should be employed (Naïve Bayes, Decision Trees, Neural Networks,
K-NN, SVM, …), matching them with the different ways of generating the dataset. 

Selected Dataset to Process: [Emotions](https://www.kaggle.com/datasets/anonymous1972/emotions)
